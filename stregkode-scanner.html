<!DOCTYPE html>
<html lang="da">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
<meta name="theme-color" content="#4CAF50" />
<meta name="mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="apple-mobile-web-app-title" content="Stregkode Scanner" />
<link rel="manifest" href="stregkode-scanner-manifest.json" />
<title id="scannerTitle">Stregkode Scanner - Telefon v4.1</title>
<style>
*{box-sizing:border-box;margin:0;padding:0;-webkit-tap-highlight-color:transparent}
body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;background:#f5f5f5;padding:4px;max-width:100%;margin:0 auto;font-size:20px;overflow-x:hidden}
.header{background:#4CAF50;color:#fff;padding:20px;border-radius:12px;margin-bottom:12px;text-align:center}
.header h1{font-size:32px;margin-bottom:8px;font-weight:700}
.header p{font-size:18px;opacity:0.95}
.scanner-container{background:#fff;border-radius:12px;padding:16px;margin-bottom:12px;box-shadow:0 2px 8px rgba(0,0,0,0.1);width:100%}
#scannerVideo{width:100% !important;height:auto !important;min-height:600px !important;max-height:90vh !important;border:5px solid #4CAF50;border-radius:12px;background:#000;display:none;position:relative;object-fit:cover}
#scannerVideo video{width:100% !important;height:auto !important;min-height:600px !important;max-height:90vh !important;object-fit:cover !important}
.status{padding:20px;margin:12px 0;border-radius:10px;text-align:center;font-weight:700;min-height:70px;display:flex;align-items:center;justify-content:center;font-size:20px;line-height:1.5;word-wrap:break-word}
.status.waiting{background:#fff3cd;color:#856404}
.status.scanning{background:#d4edda;color:#155724}
.status.success{background:#d1ecf1;color:#0c5460}
.status.error{background:#f8d7da;color:#721c24;white-space:pre-line}
.button{width:100%;padding:24px;margin:12px 0;border:none;border-radius:12px;font-size:22px;font-weight:700;cursor:pointer;background:#4CAF50;color:#fff;touch-action:manipulation;min-height:64px;transition:all 0.2s}
.button:active{opacity:0.85;transform:scale(0.97)}
.button.secondary{background:#6c757d;font-size:20px;padding:20px}
.button.danger{background:#dc3545}
.scanned-list{background:#fff;border-radius:12px;padding:20px;margin-top:12px;box-shadow:0 2px 8px rgba(0,0,0,0.1);max-height:50vh;overflow-y:auto;-webkit-overflow-scrolling:touch;width:100%}
.scanned-item{padding:18px;margin:10px 0;background:#f8f9fa;border-radius:10px;border-left:6px solid #4CAF50;display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:12px}
.scanned-item .info{flex:1;min-width:0;max-width:100%}
.scanned-item .name{font-weight:700;font-size:22px;color:#333;margin-bottom:6px;word-wrap:break-word}
.scanned-item .details{font-size:17px;color:#666;margin-top:6px;word-wrap:break-word}
.scanned-item .count{font-size:32px;font-weight:700;color:#4CAF50;margin-left:14px;min-width:60px;text-align:center;flex-shrink:0}
.scanned-item .remove{background:#dc3545;color:#fff;border:none;padding:12px 18px;border-radius:8px;cursor:pointer;font-size:18px;margin-left:10px;touch-action:manipulation;font-weight:600;flex-shrink:0}
.actions{display:flex;gap:12px;margin-top:20px;flex-wrap:wrap;width:100%}
.actions .button{flex:1;min-width:140px;font-size:18px;padding:18px}
.empty{text-align:center;padding:35px;color:#999;font-size:20px}
.stats{display:flex;gap:20px;margin:20px 0;padding:25px;background:#f8f9fa;border-radius:12px;flex-wrap:wrap}
.stat{text-align:center;flex:1;min-width:100px}
.stat-value{font-size:36px;font-weight:700;color:#4CAF50}
.stat-label{font-size:17px;color:#666;margin-top:8px}
.modal{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.75);display:flex;align-items:center;justify-content:center;z-index:1000;padding:20px;overflow-y:auto}
.modal.hidden{display:none}
.modal-content{background:white;padding:40px;border-radius:20px;max-width:min(700px, 95vw);width:100%;box-shadow:0 8px 32px rgba(0,0,0,0.3);margin:auto}
.modal-content h3{margin:0 0 30px 0;font-size:32px;color:#333;font-weight:700}
.modal-content p{font-size:20px;line-height:1.5}
.modal-content label{font-size:20px;font-weight:600;display:block;margin-bottom:12px}
.modal-content input[type="number"]{width:100%;padding:30px;font-size:42px;text-align:center;border:5px solid #4CAF50;border-radius:14px;margin:20px 0;font-weight:700}
.modal-content select{width:100%;padding:25px;font-size:26px;border:5px solid #4CAF50;border-radius:14px;margin:15px 0;background:white;font-weight:600}
.modal-buttons{display:flex;gap:15px;margin-top:35px;flex-wrap:wrap}
.modal-buttons button{flex:1;padding:25px;font-size:26px;border-radius:14px;border:none;cursor:pointer;font-weight:700;touch-action:manipulation;min-height:70px}
.modal-buttons button:active{opacity:0.85;transform:scale(0.97)}
@media (max-width:480px){
  body{padding:4px;font-size:18px}
  .header{padding:16px}
  .header h1{font-size:28px}
  .scanner-container{padding:12px}
  .button{font-size:20px;padding:20px;min-height:60px}
  .scanned-item{flex-direction:column;align-items:stretch}
  .scanned-item .count{margin-left:0;margin-top:10px;font-size:28px}
  .scanned-item .remove{margin-left:0;margin-top:10px;width:100%;padding:16px;font-size:18px}
  .stats{flex-direction:column;gap:15px}
  .stat{width:100%}
  #scannerVideo{min-height:550px !important;max-height:88vh !important}
  #scannerVideo video{min-height:550px !important;max-height:88vh !important}
  .modal-content{padding:30px}
  .modal-content h3{font-size:28px;margin-bottom:20px}
  .modal-content input[type="number"]{font-size:38px;padding:25px}
  .modal-content select{font-size:24px;padding:22px}
  .modal-buttons button{font-size:24px;padding:22px;min-height:65px}
}
@media (orientation:landscape) and (max-height:600px){
  #scannerVideo{max-height:70vh !important;min-height:400px !important}
  #scannerVideo video{max-height:70vh !important;min-height:400px !important}
  .scanned-list{max-height:40vh}
  .header{padding:12px}
  .header h1{font-size:24px;margin-bottom:4px}
}
</style>
</head>
<body>
<div class="header">
  <h1>üì± Stregkode Scanner</h1>
  <p>Scan stregkoder med din telefon - v<span id="versionDisplayScanner">4.1</span></p>
</div>

<div class="scanner-container">
  <div id="status" class="status waiting">Klik "Start Scanner" for at begynde</div>
  <div id="scannerVideo"></div>
  <button id="startBtn" class="button" onclick="showLocationSelection()">üì∑ Start Opt√¶lling</button>
  <button id="stopBtn" class="button secondary" onclick="stopScanner()" style="display:none">‚èπ Stop Scanner</button>
</div>

<div class="stats" id="stats" style="display:none">
  <div class="stat">
    <div class="stat-value" id="totalScanned">0</div>
    <div class="stat-label">Total scannet</div>
  </div>
  <div class="stat">
    <div class="stat-value" id="uniqueItems">0</div>
    <div class="stat-label">Unikke varer</div>
  </div>
</div>

<div class="scanned-list">
  <h3 style="margin-bottom:10px">Scannede varer (<span id="count">0</span>)</h3>
  <div id="scannedList">
    <div class="empty">Ingen varer scannet endnu</div>
  </div>
  <div class="actions">
    <div id="varelagerUpdateNotificationScanner" style="display:none; background:#ffc107; color:#000; padding:8px 12px; border-radius:6px; font-size:12px; font-weight:600; margin-right:8px; cursor:pointer; white-space:nowrap;" onclick="fetchVarelagerFromServer()" title="Klik for at hente nyt varelager">
      ‚ö†Ô∏è Nyt varelager tilg√¶ngeligt
    </div>
    <button class="button secondary" onclick="clearAll()" style="font-size:13px; padding:10px 16px; border-radius:6px; font-weight:600;">üóë Ryd alt</button>
    <button class="button secondary" onclick="fetchVarelagerFromServer()" style="font-size:13px; padding:10px 16px; background:#17a2b8; color:white; border-radius:6px; font-weight:600; box-shadow:0 2px 4px rgba(0,0,0,0.2);">‚òÅÔ∏è Hent varelager</button>
    <button class="button secondary" onclick="uploadReportsToServer()" style="font-size:13px; padding:10px 16px; background:#28a745; color:white; border-radius:6px; font-weight:600; box-shadow:0 2px 4px rgba(0,0,0,0.2);">‚òÅÔ∏è Upload rapporter</button>
    <button class="button" onclick="finishSession()" style="font-size:14px; padding:10px 16px; border-radius:6px; font-weight:600; box-shadow:0 2px 4px rgba(0,0,0,0.2);">‚úÖ Afslut opt√¶lling</button>
  </div>
</div>

<!-- Modal til lokationsvalg -->
<div id="locationModal" class="modal hidden">
  <div class="modal-content">
    <h3>üìç V√¶lg Lokation</h3>
    <p style="margin-bottom:25px; color:#666; font-size:20px; line-height:1.5;">V√¶lg hvilken lokation du vil opt√¶lle. Du kan v√¶lge "Alle lokationer" for at opt√¶lle alle.</p>
    <div style="margin:30px 0">
      <label for="locationSelect" style="display:block;margin-bottom:15px;font-weight:600;font-size:20px;">Lokation:</label>
      <select id="locationSelect" style="width:100%;padding:25px;font-size:26px;border:5px solid #4CAF50;border-radius:14px;font-weight:600;">
        <option value="">Alle lokationer</option>
      </select>
    </div>
    <div class="modal-buttons">
      <button onclick="cancelLocationSelection()" style="background:#6c757d;color:white;">Annuller</button>
      <button onclick="confirmLocationSelection()" style="background:#4CAF50;color:white;">Start Opt√¶lling</button>
    </div>
  </div>
</div>

<!-- Modal til antalsindtastning -->
<div id="quantityModal" class="modal hidden">
  <div class="modal-content">
    <h3>Indtast antal</h3>
    <div id="scannedCodeDisplay" style="font-size:22px;font-weight:600;margin:25px 0;color:#4CAF50;line-height:1.5;"></div>
    <div style="margin:30px 0">
      <label for="quantityInput" style="display:block;margin-bottom:15px;font-weight:600;font-size:20px;">Antal:</label>
      <input type="number" id="quantityInput" min="1" value="1" style="width:100%;padding:30px;font-size:42px;text-align:center;border:5px solid #4CAF50;border-radius:14px;font-weight:700;" autofocus onkeypress="if(event.key==='Enter') confirmQuantityInput()">
    </div>
    <div class="modal-buttons">
      <button onclick="cancelQuantityInput()" style="background:#6c757d;color:white;">Annuller</button>
      <button onclick="confirmQuantityInput()" style="background:#4CAF50;color:white;">Gem</button>
    </div>
  </div>
</div>

<script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>
<script>
// Versionsnummer - opdateres automatisk
const APP_VERSION = '4.1';

let scannerActive = false;
let html5QrCode = null;
let scannedItems = {};
let allItems = [];
let lastScannedCode = null;
let lastScanTime = 0;
let selectedLocation = ''; // Selected location for current session
let availableLocations = []; // Available locations from varelager
let pendingScannedCode = null; // For quantity dialog
let pendingScannedItemId = null; // Store item.id when item is found
let qrScanMode = false; // QR scan mode for importing varelager
const SCAN_COOLDOWN = 1000;

// Load items from main app
function loadItemsFromMainApp(){
  try {
    const storageKey = 'k√∏kkenlager_data';
    const dataStr = localStorage.getItem(storageKey);
    
    console.log('Checking localStorage for key:', storageKey);
    console.log('Data found:', !!dataStr);
    
    if (!dataStr) {
      // No data found - allow scanning anyway but warn user
      const currentDomain = window.location.hostname;
      const isGitHub = currentDomain.includes('github.io');
      
      if (isGitHub) {
        updateStatus('‚ö†Ô∏è Ingen varelager data fundet.\n\nDu kan stadig scanne stregkoder, men varer vil ikke blive matchet.\n\nüí° Tip: Eksporter data fra hovedprogrammet og importer her.', 'error');
      } else {
        updateStatus('‚ö†Ô∏è Ingen varelager data fundet.\n\nDu kan stadig scanne stregkoder.\n\nüí° Tip: √Öbn hovedprogrammet p√• samme enhed f√∏rst.', 'error');
      }
      
      allItems = [];
      return false; // Return false but don't block the app
    }
    
    const data = JSON.parse(dataStr);
    console.log('Parsed data keys:', Object.keys(data));
    console.log('masterVarelager length:', data.masterVarelager ? data.masterVarelager.length : 0);
    
    allItems = data.masterVarelager || [];
    
    // Load available locations from lagerLokationer
    availableLocations = data.lagerLokationer || [];
    if (availableLocations.length === 0 && allItems.length > 0) {
      // Extract unique locations from items if lagerLokationer is not available
      const uniqueLocs = [...new Set(allItems.map(item => item.placering).filter(p => p))];
      availableLocations = uniqueLocs;
    }
    
    // Sync installation ID from main program if available - ALWAYS update to match
    if (data.mainInstallationId) {
      // Extract numeric part from main ID (e.g., "INST-123456" -> "123456")
      const mainIdNum = data.mainInstallationId.replace(/[^0-9]/g, '');
      // Create matching scanner ID
      const newScannerId = 'SCANNER-' + mainIdNum;
      // Always update to ensure they match
      if (data.scannerInstallationId !== newScannerId || !data.installationId || !data.installationId.startsWith('SCANNER-')) {
        data.scannerInstallationId = newScannerId;
        data.installationId = newScannerId;
        localStorage.setItem(storageKey, JSON.stringify(data));
        console.log('‚úÖ ID synkroniseret fra hovedprogram:', {
          main: data.mainInstallationId,
          scanner: newScannerId
        });
      }
    }
    
    if (allItems.length === 0) {
      updateStatus('‚ö†Ô∏è Varelageret er tomt.\n\nDu kan stadig scanne stregkoder.', 'error');
      return false;
    }
    
    console.log('‚úÖ Indl√¶st ' + allItems.length + ' varer fra hovedprogrammet');
    return true;
  } catch (err) {
    console.error('Fejl ved indl√¶sning af varer:', err);
    updateStatus('Fejl ved indl√¶sning af varer: ' + err.message + '\n\nDu kan stadig scanne stregkoder.', 'error');
    allItems = [];
    return false;
  }
}

function updateStatus(text, type){
  const status = document.getElementById('status');
  status.textContent = text;
  status.className = 'status ' + (type || 'waiting');
}

// Show location selection modal
function showLocationSelection() {
  // Load items first to get locations
  loadItemsFromMainApp();
  
  const modal = document.getElementById('locationModal');
  const select = document.getElementById('locationSelect');
  
  if (!modal || !select) return;
  
  // Populate location dropdown
  select.innerHTML = '<option value="">Alle lokationer</option>';
  availableLocations.forEach(loc => {
    const option = document.createElement('option');
    option.value = loc;
    option.textContent = loc;
    select.appendChild(option);
  });
  
  // If no locations available, show message
  if (availableLocations.length === 0) {
    select.innerHTML = '<option value="">Ingen lokationer fundet - brug "Alle lokationer"</option>';
  }
  
  modal.classList.remove('hidden');
}

// Confirm location selection and start scanner
function confirmLocationSelection() {
  const select = document.getElementById('locationSelect');
  if (!select) return;
  
  selectedLocation = select.value || '';
  hideLocationModal();
  
  // Start scanner after location is selected
  startScannerAfterLocation();
}

// Cancel location selection
function cancelLocationSelection() {
  hideLocationModal();
}

// Hide location modal
function hideLocationModal() {
  const modal = document.getElementById('locationModal');
  if (modal) {
    modal.classList.add('hidden');
  }
}

// Start scanner (wrapper function for QR mode)
async function startScanner(){
  // For QR mode, start directly without location selection
  if (qrScanMode) {
    await startScannerAfterLocation();
    return;
  }
  // For normal scanning, show location selection first
  showLocationSelection();
}

// Start scanner after location is selected
async function startScannerAfterLocation(){
  if(scannerActive){
    stopScanner();
    return;
  }
  
  // Allow scanning even without varelager data
  if (allItems.length === 0) {
    console.warn('No varelager data - scanning will work but items won\'t be matched');
  }
  
  const status = document.getElementById('status');
  const video = document.getElementById('scannerVideo');
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  
  const isSecure = window.location.protocol === 'https:' || 
                   window.location.hostname === 'localhost' || 
                   window.location.hostname === '127.0.0.1';
  
  if(!isSecure && window.location.protocol === 'file:'){
    updateStatus('‚ö†Ô∏è KAMERA KR√ÜVER WEBSERVER\n\nFilen skal hostes p√• en webserver for at kameraet virker.\n\nBrug webserveren fra hovedprogrammet eller GitHub Pages.', 'error');
    return;
  }
  
  if(typeof Html5Qrcode === 'undefined'){
    updateStatus('‚ö†Ô∏è Scanner bibliotek ikke indl√¶st.\n\nGenindl√¶s siden og tjek din internetforbindelse.', 'error');
    console.error('Html5Qrcode library not available');
    return;
  }
  
  updateStatus('Starter kamera...', 'waiting');
  
  try {
    // Stop existing scanning first if active
    if (html5QrCode && html5QrCode.isScanning) {
      try {
        await html5QrCode.stop();
        html5QrCode.clear();
      } catch (stopErr) {
        console.warn('Fejl ved stop af eksisterende scanning:', stopErr);
      }
    }
    
    video.style.display = 'block';
    scannerActive = true;
    
    // Clear video container first
    video.innerHTML = '';
    
    html5QrCode = new Html5Qrcode("scannerVideo");
    
    // Configuration optimized for mobile - MUCH larger scanning area for Android
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const isAndroid = /Android/i.test(navigator.userAgent);
    
    // Use MUCH larger scanning area - focus on height for better barcode scanning
    let qrboxSize;
    if (isAndroid) {
      // Android: Use 98% of screen width, but prioritize height for barcode scanning
      // Make it taller (more height) for better barcode reading
      const screenWidth = window.innerWidth;
      const screenHeight = window.innerHeight;
      // Use almost full width but make it taller for barcodes
      qrboxSize = Math.max(450, Math.min(screenWidth * 0.98, screenHeight * 0.8));
      console.log('Android detected - using large qrbox:', qrboxSize, 'Screen:', screenWidth, 'x', screenHeight);
    } else if (isMobile) {
      // Other mobile: Use 95% of screen width
      qrboxSize = Math.max(400, Math.min(window.innerWidth * 0.95, window.innerHeight * 0.75));
    } else {
      // Desktop
      qrboxSize = 500;
    }
    
    const config = {
      fps: isAndroid ? 20 : 15, // Higher FPS for Android for better scanning
      qrbox: { width: qrboxSize, height: qrboxSize * 1.2 }, // Make it taller (1.2x) for better barcode scanning
      aspectRatio: 1.0,
      disableFlip: false, // Allow rotation
      videoConstraints: {
        facingMode: "environment",
        width: { ideal: 1920 }, // Higher resolution for better scanning
        height: { ideal: 1080 }
      }
    };
    
    // Try to get back camera first
    let cameraId = { facingMode: "environment" };
    try {
      const devices = await Html5Qrcode.getCameras();
      if (devices && devices.length > 0) {
        const backCamera = devices.find(device => 
          device.label.toLowerCase().includes('back') || 
          device.label.toLowerCase().includes('rear') ||
          device.label.toLowerCase().includes('environment')
        );
        if (backCamera) {
          cameraId = backCamera.id;
          console.log('Using back camera:', backCamera.label);
        } else {
          cameraId = devices[0].id;
          console.log('Using first available camera:', devices[0].label);
        }
      }
    } catch (camErr) {
      console.warn('Could not enumerate cameras, using default:', camErr);
      // Continue with default facingMode
    }
    
    await html5QrCode.start(
      cameraId,
      config,
      (decodedText, decodedResult) => {
        console.log('‚úÖ Scannet stregkode/QR-kode:', decodedText);
        const now = Date.now();
        
        if (now - lastScanTime < SCAN_COOLDOWN && decodedText === lastScannedCode) {
          return;
        }
        
        lastScannedCode = decodedText;
        lastScanTime = now;
        
        // Check if this is a varelager QR code
        if (qrScanMode && decodedText.startsWith('VARELAGER:')) {
          handleVarelagerQR(decodedText);
        } else if (!qrScanMode) {
          // Show quantity dialog without stopping scanner
          // Scanner continues in background
          showQuantityDialog(decodedText);
        }
      },
      (errorMessage) => {
        // Ignorer scanning fejl - de er normale n√•r der ikke er fundet noget
      }
    );
    
    updateStatus('Peger p√• stregkoden...', 'scanning');
    startBtn.style.display = 'none';
    stopBtn.style.display = 'block';
    document.getElementById('stats').style.display = 'flex';
    
  } catch(err){
    console.error('Kamera fejl:', err);
    scannerActive = false;
    let errorMsg = '';
    let instructions = '';
    if(err.name === 'NotAllowedError'){
      errorMsg = 'Kamera tilladelse n√¶gtet.';
      instructions = 'Giv tilladelse til kamera:\n1. Klik p√• kamera-ikonet i browserens adresselinje\n2. V√¶lg "Tillad" for kamera\n3. Genindl√¶s siden og pr√∏v igen';
    } else if(err.name === 'NotFoundError'){
      errorMsg = 'Ingen kamera fundet.';
      instructions = 'Tjek at dit kamera er tilsluttet og ikke bruges af andre programmer.';
    } else {
      errorMsg = 'Kunne ikke starte scanner: ' + (err.message || err.name);
      instructions = 'Pr√∏v:\n1. Genindl√¶s siden\n2. Tjek browser tilladelser for kamera\n3. S√∏rg for at filen hostes p√• en webserver';
    }
    updateStatus(errorMsg + '\n\n' + instructions, 'error');
    startBtn.style.display = 'block';
    stopBtn.style.display = 'none';
    video.style.display = 'none';
  }
}

// Show quantity dialog when barcode is scanned
function showQuantityDialog(barcode){
  pendingScannedCode = barcode;
  pendingScannedItemId = null; // Reset
  const modal = document.getElementById('quantityModal');
  const codeDisplay = document.getElementById('scannedCodeDisplay');
  const quantityInput = document.getElementById('quantityInput');
  
  // Find item to show name - use same matching logic as handleScannedBarcode
  const barcodeStr = String(barcode).trim();
  const barcodeNormalized = normalizeBarcode(barcode);
  
  // First try exact and case-insensitive matches
  let item = allItems.find(v => {
    const vId = String(v.id || '').trim();
    const vStregkode = String(v.stregkode || '').trim();
    
    // Exact matches
    if (vId === barcodeStr || vStregkode === barcodeStr) return true;
    
    // Case-insensitive matches
    if (vId.toLowerCase() === barcodeStr.toLowerCase() || 
        vStregkode.toLowerCase() === barcodeStr.toLowerCase()) return true;
    
    // Normalized matches
    const vIdNorm = normalizeBarcode(vId);
    const vStregkodeNorm = normalizeBarcode(vStregkode);
    if (vIdNorm === barcodeNormalized || vStregkodeNorm === barcodeNormalized) return true;
    
    // Partial matches
    if (vIdNorm.includes(barcodeNormalized) || barcodeNormalized.includes(vIdNorm)) return true;
    if (vStregkodeNorm.includes(barcodeNormalized) || barcodeNormalized.includes(vStregkodeNorm)) return true;
    
    return false;
  });
  
  // If not found, try fuzzy matching
  if (!item && barcodeNormalized.length >= 5) {
    let bestMatch = null;
    let bestSimilarity = 0.6;
    
    for (const v of allItems) {
      const vId = String(v.id || '').trim();
      const vStregkode = String(v.stregkode || '').trim();
      
      const similarity1 = calculateSimilarity(barcodeStr, vId);
      const similarity2 = calculateSimilarity(barcodeStr, vStregkode);
      const maxSimilarity = Math.max(similarity1, similarity2);
      
      if (maxSimilarity > bestSimilarity) {
        bestSimilarity = maxSimilarity;
        bestMatch = v;
      }
    }
    
    if (bestMatch) {
      item = bestMatch;
    }
  }
  
  if (item) {
    // Gem item.id s√• vi kan bruge det direkte i handleScannedBarcode
    pendingScannedItemId = item.id;
    
    const maaleenhed = item.maaleenhed || 'stk';
    const pris = item.pris !== undefined ? Number(item.pris) : 0;
    const prisText = pris > 0 ? ` ‚Ä¢ ${pris.toFixed(2)} kr. pr. ${maaleenhed}` : '';
    
    let displayHTML = '<div style="display:flex; align-items:center; gap:15px;">';
    
    // Vis billede hvis tilg√¶ngelig (st√∏rre og til h√∏jre)
    if (item.billede) {
      displayHTML += `<div style="flex-shrink:0;">
        <img src="${item.billede}" alt="${item.navn}" style="max-width:120px; max-height:120px; border:2px solid #4CAF50; border-radius:6px; object-fit:contain;">
      </div>`;
    }
    
    // Vare info til venstre
    displayHTML += `<div style="flex:1;">
      <strong style="font-size:18px;">${item.navn}</strong><br>
      <span style="font-size:14px; color:#666;">${maaleenhed}${prisText}</span>`;
    
    // Vis varenummer hvis tilg√¶ngelig
    if (item.varenummer) {
      displayHTML += `<br><span style="font-size:12px; color:#17a2b8; font-weight:600;">Varenummer: ${item.varenummer}</span>`;
    }
    
    displayHTML += `</div></div>`;
    codeDisplay.innerHTML = displayHTML;
  } else {
    codeDisplay.textContent = 'Stregkode: ' + barcode;
  }
  
  quantityInput.value = '1';
  quantityInput.focus();
  quantityInput.select();
  
  modal.classList.remove('hidden');
}

// Confirm quantity and add item
function confirmQuantityInput(){
  const modal = document.getElementById('quantityModal');
  const quantityInput = document.getElementById('quantityInput');
  const quantity = parseInt(quantityInput.value) || 1;
  
  if (quantity <= 0) {
    alert('‚ö†Ô∏è Antal skal v√¶re st√∏rre end 0');
    quantityInput.focus();
    return;
  }
  
  if (pendingScannedCode) {
    // Hvis vi har item.id, brug det direkte - ellers brug barcode
    if (pendingScannedItemId) {
      handleScannedBarcode(pendingScannedItemId, quantity);
    } else {
      handleScannedBarcode(pendingScannedCode, quantity);
    }
    pendingScannedCode = null;
    pendingScannedItemId = null;
  }
  
  modal.classList.add('hidden');
  
  // Scanner continues automatically - no need to restart
  if (scannerActive && !qrScanMode) {
    updateStatus('Peger p√• stregkoden...', 'scanning');
  }
}

// Cancel quantity input
function cancelQuantityInput(){
  const modal = document.getElementById('quantityModal');
  pendingScannedCode = null;
  pendingScannedItemId = null;
  modal.classList.add('hidden');
  
  // Scanner continues automatically - no need to restart
  if (scannerActive && !qrScanMode) {
    updateStatus('Peger p√• stregkoden...', 'scanning');
  }
}

// Normalize barcode string - remove special characters and normalize
function normalizeBarcode(str) {
  if (!str) return '';
  // Convert to string, trim, and normalize
  let normalized = String(str).trim();
  // Remove common problematic characters that might be misread
  normalized = normalized.replace(/[~$#\\\/]/g, '');
  // Normalize similar-looking characters
  normalized = normalized.replace(/[0O]/g, '0'); // Normalize O to 0
  normalized = normalized.replace(/[1Il]/g, '1'); // Normalize I and l to 1
  return normalized.toLowerCase();
}

// Calculate similarity between two strings (simple Levenshtein-like)
function calculateSimilarity(str1, str2) {
  if (!str1 || !str2) return 0;
  const s1 = normalizeBarcode(str1);
  const s2 = normalizeBarcode(str2);
  
  if (s1 === s2) return 1.0;
  
  // Check if one contains the other (partial match)
  if (s1.includes(s2) || s2.includes(s1)) return 0.8;
  
  // Calculate character overlap
  const longer = s1.length > s2.length ? s1 : s2;
  const shorter = s1.length > s2.length ? s2 : s1;
  
  if (longer.length === 0) return 1.0;
  
  // Count matching characters in order
  let matches = 0;
  let shortIndex = 0;
  for (let i = 0; i < longer.length && shortIndex < shorter.length; i++) {
    if (longer[i] === shorter[shortIndex]) {
      matches++;
      shortIndex++;
    }
  }
  
  return matches / longer.length;
}

function handleScannedBarcode(barcode, quantity = 1){
  // Try to find item in varelager - match on both id and stregkode
  // Also try case-insensitive matching, partial matching, and fuzzy matching
  const barcodeStr = String(barcode).trim();
  const barcodeNormalized = normalizeBarcode(barcode);
  
  // First try exact and case-insensitive matches
  let item = allItems.find(v => {
    const vId = String(v.id || '').trim();
    const vStregkode = String(v.stregkode || '').trim();
    
    // Exact matches
    if (vId === barcodeStr || vStregkode === barcodeStr) return true;
    
    // Case-insensitive matches
    if (vId.toLowerCase() === barcodeStr.toLowerCase() || 
        vStregkode.toLowerCase() === barcodeStr.toLowerCase()) return true;
    
    // Normalized matches (handles special characters)
    const vIdNorm = normalizeBarcode(vId);
    const vStregkodeNorm = normalizeBarcode(vStregkode);
    if (vIdNorm === barcodeNormalized || vStregkodeNorm === barcodeNormalized) return true;
    
    // Partial matches (one contains the other)
    if (vIdNorm.includes(barcodeNormalized) || barcodeNormalized.includes(vIdNorm)) return true;
    if (vStregkodeNorm.includes(barcodeNormalized) || barcodeNormalized.includes(vStregkodeNorm)) return true;
    
    return false;
  });
  
  // If not found, try fuzzy matching (similarity-based)
  if (!item && barcodeNormalized.length >= 5) { // Only fuzzy match if barcode is reasonably long
    let bestMatch = null;
    let bestSimilarity = 0.6; // Minimum similarity threshold
    
    for (const v of allItems) {
      const vId = String(v.id || '').trim();
      const vStregkode = String(v.stregkode || '').trim();
      
      const similarity1 = calculateSimilarity(barcodeStr, vId);
      const similarity2 = calculateSimilarity(barcodeStr, vStregkode);
      const maxSimilarity = Math.max(similarity1, similarity2);
      
      if (maxSimilarity > bestSimilarity) {
        bestSimilarity = maxSimilarity;
        bestMatch = v;
      }
    }
    
    if (bestMatch) {
      console.log(`Fuzzy match found: "${barcodeStr}" matched "${bestMatch.id}" or "${bestMatch.stregkode}" with similarity ${(bestSimilarity * 100).toFixed(1)}%`);
      item = bestMatch;
    }
  }
  
  if (!item) {
    // Item not found - try to find similar items for debugging
    const similarItems = [];
    const barcodeNormalized = normalizeBarcode(barcode);
    
    // Find items with similar IDs or stregkoder
    for (const v of allItems) {
      const vId = String(v.id || '').trim();
      const vStregkode = String(v.stregkode || '').trim();
      const vIdNorm = normalizeBarcode(vId);
      const vStregkodeNorm = normalizeBarcode(vStregkode);
      
      // Check if any part matches (at least 5 characters)
      if (barcodeNormalized.length >= 5) {
        if (vIdNorm.includes(barcodeNormalized.substring(0, 5)) || 
            barcodeNormalized.includes(vIdNorm.substring(0, Math.min(5, vIdNorm.length))) ||
            vStregkodeNorm.includes(barcodeNormalized.substring(0, 5)) || 
            barcodeNormalized.includes(vStregkodeNorm.substring(0, Math.min(5, vStregkodeNorm.length)))) {
          similarItems.push({ id: vId, stregkode: vStregkode, navn: v.navn });
        }
      }
    }
    
    // Log for debugging
    console.warn('Item not found:', {
      scanned: barcode,
      normalized: barcodeNormalized,
      similarItems: similarItems.slice(0, 5), // Show first 5 similar items
      totalItems: allItems.length
    });
    
    // Still add it but with limited info - brug barcode som n√∏gle n√•r item ikke findes
    const unknownItemKey = barcode;
    if (!scannedItems[unknownItemKey]) {
      scannedItems[unknownItemKey] = {
        vare: {
          id: barcode,
          navn: 'Ukendt vare (' + barcode + ')',
          placering: 'Ikke angivet',
          maaleenhed: 'stk',
          pris: 0,
          reolNr: null, // Explicitly set to null
          hylleNr: null, // Explicitly set to null
          billede: null,
          varenummer: null
        },
        count: 0
      };
    }
    
    scannedItems[unknownItemKey].count += quantity;
    
    // Show more helpful error message
    let errorMsg = '‚ö†Ô∏è Vare ikke fundet: ' + barcode + '\n(Tilf√∏jet: ' + quantity + ')';
    if (similarItems.length > 0) {
      errorMsg += '\n\nüí° Fundet lignende varer:\n';
      similarItems.slice(0, 3).forEach(s => {
        errorMsg += `- ${s.navn} (ID: ${s.id}${s.stregkode ? ', Stregkode: ' + s.stregkode : ''})\n`;
      });
      errorMsg += '\nTjek om stregkoden er korrekt l√¶st.';
    } else {
      errorMsg += '\n\nüí° Tjek:\n1. Er stregkoden korrekt l√¶st?\n2. Findes varen i varelageret?\n3. Er stregkoden tilf√∏jet til varen?';
    }
    
    updateStatus(errorMsg, 'error');
    
    updateStats();
    renderList();
    
    if (navigator.vibrate) {
      navigator.vibrate(50);
    }
    
    return;
  }
  
  // Item found - add normally
  // VIGTIGT: Brug item.id som n√∏gle, ikke barcode, for at undg√• at samme vare bliver gemt flere gange med forskellige barcodes
  const itemKey = item.id || barcode;
  
  // Ensure all fields are present from varelager - explicitly get all fields
  if (!scannedItems[itemKey]) {
    scannedItems[itemKey] = {
      vare: {
        id: item.id || barcode,
        navn: item.navn || 'Ukendt vare',
        placering: item.placering || 'Ikke angivet',
        maaleenhed: item.maaleenhed || 'stk',
        pris: item.pris !== undefined ? Number(item.pris) : 0,
        reolNr: item.reolNr !== undefined && item.reolNr !== null && item.reolNr !== '' ? item.reolNr : null,
        hylleNr: item.hylleNr !== undefined && item.hylleNr !== null && item.hylleNr !== '' ? item.hylleNr : null,
        billede: item.billede || null,
        varenummer: item.varenummer || null
      },
      count: 0
    };
    
    // Debug log to verify all fields are captured
    console.log('Item scanned and stored:', {
      id: scannedItems[itemKey].vare.id,
      navn: scannedItems[itemKey].vare.navn,
      varenummer: scannedItems[itemKey].vare.varenummer,
      reolNr: scannedItems[itemKey].vare.reolNr,
      hylleNr: scannedItems[itemKey].vare.hylleNr,
      pris: scannedItems[itemKey].vare.pris,
      placering: scannedItems[itemKey].vare.placering
    });
  }
  
  scannedItems[itemKey].count += quantity;
  
  const itemName = item.navn || 'Ukendt vare';
  updateStatus('‚úÖ ' + itemName + ' tilf√∏jet: ' + quantity, 'success');
  
  updateStats();
  renderList();
  
  if (navigator.vibrate) {
    navigator.vibrate(50);
  }
}

function updateStats(){
  const total = Object.values(scannedItems).reduce((sum, item) => sum + item.count, 0);
  const unique = Object.keys(scannedItems).length;
  
  document.getElementById('totalScanned').textContent = total;
  document.getElementById('uniqueItems').textContent = unique;
  document.getElementById('count').textContent = total;
}

function renderList(){
  const list = document.getElementById('scannedList');
  const items = Object.values(scannedItems);
  
  if(items.length === 0){
    list.innerHTML = '<div class="empty">Ingen varer scannet endnu</div>';
    return;
  }
  
  // Group by location
  const itemsByLocation = {};
  items.forEach(item => {
    const location = item.vare.placering || 'Ikke angivet';
    if (!itemsByLocation[location]) {
      itemsByLocation[location] = [];
    }
    itemsByLocation[location].push(item);
  });
  
  let html = '';
  Object.keys(itemsByLocation).sort().forEach(location => {
    html += `<div style="margin-bottom:15px; padding:10px; background:#f0f0f0; border-radius:6px;">`;
    html += `<div style="font-weight:700; font-size:14px; color:#4CAF50; margin-bottom:8px;">üìç ${location}</div>`;
    
    itemsByLocation[location].forEach((item, idx) => {
      const v = item.vare;
      const key = Object.keys(scannedItems).find(k => scannedItems[k] === item);
      const maaleenhed = v.maaleenhed || 'stk';
      const pris = v.pris !== undefined ? Number(v.pris) : 0;
      const prisText = pris > 0 ? ` ‚Ä¢ ${pris.toFixed(2)} kr. pr. ${maaleenhed}` : '';
      // Tilf√∏j billede hvis tilg√¶ngelig (lille format til telefon)
      let imageHTML = '';
      if (v.billede) {
        imageHTML = `<img src="${v.billede}" alt="${v.navn}" style="width:50px; height:50px; object-fit:contain; border:1px solid #ddd; border-radius:4px; margin-right:10px; flex-shrink:0;">`;
      }
      
      html += `
        <div class="scanned-item" style="display:flex; align-items:center;">
          ${imageHTML}
          <div class="info" style="flex:1;">
            <div class="name">${v.navn}</div>
            <div class="details">${maaleenhed}${prisText}${v.reolNr ? ' ‚Ä¢ Reol ' + v.reolNr : ''}${v.hylleNr ? ' ‚Ä¢ Hylle ' + v.hylleNr : ''}${v.varenummer ? ' ‚Ä¢ Varenr: ' + v.varenummer : ''}</div>
          </div>
          <div class="count">${item.count}</div>
          <button class="remove" onclick="removeItem('${key}')">Slet</button>
        </div>
      `;
    });
    
    html += `</div>`;
  });
  
  list.innerHTML = html;
}

function removeItem(key){
  delete scannedItems[key];
  updateStats();
  renderList();
}

function clearAll(){
  if(confirm('Er du sikker p√• at du vil slette alle scannede varer?')){
    scannedItems = {};
    selectedLocation = ''; // Reset location
    updateStats();
    renderList();
    updateStatus('Alle varer ryddet', 'waiting');
  }
}

// Check data connection
// checkDataConnection function removed - not needed

// Scan QR code to import varelager
function scanVarelagerQR(){
  if (scannerActive) {
    alert('‚ö†Ô∏è Stop scanneren f√∏rst for at scanne QR-kode.');
    return;
  }
  
  qrScanMode = true;
  updateStatus('üì± Scan QR-koden fra hovedprogrammet...', 'waiting');
  
  // Start scanner in QR mode
  startScanner();
}

// Handle varelager QR code scan
function handleVarelagerQR(qrData){
  try {
    // Remove prefix
    const base64Data = qrData.replace('VARELAGER:', '');
    
    // Decode base64
    const jsonString = decodeURIComponent(escape(atob(base64Data)));
    
    // Parse JSON
    const importedData = JSON.parse(jsonString);
    
    if (!importedData.masterVarelager || !Array.isArray(importedData.masterVarelager)) {
      updateStatus('‚ùå QR-koden indeholder ikke varelager data.', 'error');
      qrScanMode = false;
      return;
    }
    
    // Load existing data or create new
    const storageKey = 'k√∏kkenlager_data';
    let existingData = {};
    const existingStr = localStorage.getItem(storageKey);
    if (existingStr) {
      try {
        existingData = JSON.parse(existingStr);
      } catch(err) {
        console.warn('Could not parse existing data:', err);
      }
    }
    
    // Merge imported varelager with existing data
    existingData.masterVarelager = importedData.masterVarelager;
    if (importedData.lagerLokationer) {
      existingData.lagerLokationer = importedData.lagerLokationer;
    }
    
    // Sync installation ID from main program - ALWAYS update to match
    if (importedData.mainInstallationId) {
      existingData.mainInstallationId = importedData.mainInstallationId;
      // Extract numeric part from main ID (e.g., "INST-123456" -> "123456")
      const mainIdNum = importedData.mainInstallationId.replace(/[^0-9]/g, '');
      // Create matching scanner ID
      const newScannerId = 'SCANNER-' + mainIdNum;
      existingData.scannerInstallationId = newScannerId;
      existingData.installationId = newScannerId;
      console.log('‚úÖ ID synkroniseret fra hovedprogram:', {
        main: importedData.mainInstallationId,
        scanner: newScannerId
      });
    }
    
    // Save merged data
    localStorage.setItem(storageKey, JSON.stringify(existingData));
    
    // Reload items
    allItems = importedData.masterVarelager;
    
    // Store lagerLokationer for reference
    if (importedData.lagerLokationer && Array.isArray(importedData.lagerLokationer)) {
      console.log('Imported locations:', importedData.lagerLokationer);
    }
    
    // Stop scanner
    stopScanner();
    qrScanMode = false;
    
    const locationInfo = importedData.lagerLokationer && importedData.lagerLokationer.length > 0 
      ? '\nüìç Placeringer: ' + importedData.lagerLokationer.join(', ')
      : '';
    
    alert('‚úÖ Varelager importeret!\n\n' + allItems.length + ' varer er nu tilg√¶ngelige.' + locationInfo);
    updateStatus('‚úÖ Varelager importeret: ' + allItems.length + ' varer' + locationInfo, 'success');
    
    console.log('Imported varelager from QR:', allItems.length, 'items');
    console.log('Imported locations:', importedData.lagerLokationer);
  } catch(err) {
    console.error('Error importing from QR:', err);
    updateStatus('‚ùå Fejl ved import: ' + err.message, 'error');
    qrScanMode = false;
    setTimeout(() => {
      if(scannerActive){
        updateStatus('Peger p√• stregkoden...', 'scanning');
      }
    }, 3000);
  }
}

// Parse CSV to varelager format
function parseCSVToVarelager(csvContent) {
  try {
    // Remove BOM if present
    if (csvContent.charCodeAt(0) === 0xFEFF) {
      csvContent = csvContent.substring(1);
    }
    
    const lines = csvContent.split('\n').filter(line => line.trim());
    if (lines.length < 2) {
      throw new Error('CSV filen er tom eller mangler data');
    }
    
    // Parse header
    const header = lines[0].split(';').map(h => h.trim());
    const navnIdx = header.findIndex(h => h.toLowerCase().includes('navn'));
    const maaleenhedIdx = header.findIndex(h => h.toLowerCase().includes('m√•leenhed') || h.toLowerCase().includes('maaleenhed'));
    const prisIdx = header.findIndex(h => h.toLowerCase().includes('pris'));
    const placeringIdx = header.findIndex(h => h.toLowerCase().includes('placering'));
    const reolIdx = header.findIndex(h => h.toLowerCase().includes('reol'));
    const hylleIdx = header.findIndex(h => h.toLowerCase().includes('hylle'));
    const raekkefoelgeIdx = header.findIndex(h => h.toLowerCase().includes('r√¶kkef√∏lge') || h.toLowerCase().includes('raekkefoelge'));
    
    if (navnIdx === -1) {
      throw new Error('CSV filen mangler "Navn" kolonne');
    }
    
    const masterVarelager = [];
    const locations = new Set();
    
    // Parse data rows
    for (let i = 1; i < lines.length; i++) {
      const values = lines[i].split(';').map(v => v.trim());
      if (values.length === 0 || !values[navnIdx]) continue;
      
      const navn = values[navnIdx];
      const maaleenhed = maaleenhedIdx >= 0 ? values[maaleenhedIdx] : 'stk';
      const pris = prisIdx >= 0 ? parseFloat(values[prisIdx].replace(',', '.')) || 0 : 0;
      const placering = placeringIdx >= 0 ? values[placeringIdx] : '';
      const reolNr = reolIdx >= 0 ? values[reolIdx] : '';
      const hylleNr = hylleIdx >= 0 ? values[hylleIdx] : '';
      const raekkefoelge = raekkefoelgeIdx >= 0 ? parseInt(values[raekkefoelgeIdx]) || 0 : 0;
      
      if (placering) locations.add(placering);
      
      // Generate ID from name (simple hash)
      const id = navn.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '') + '_' + Date.now() + '_' + i;
      
      masterVarelager.push({
        id: id,
        navn: navn,
        maaleenhed: maaleenhed,
        pris: pris,
        placering: placering,
        reolNr: reolNr || undefined,
        hylleNr: hylleNr || undefined,
        raekkefoelge: raekkefoelge || undefined
      });
    }
    
    return {
      masterVarelager: masterVarelager,
      lagerLokationer: Array.from(locations).filter(l => l)
    };
  } catch(err) {
    throw new Error('Fejl ved parsing af CSV: ' + err.message);
  }
}

// Import varelager from JSON or CSV file
function importVarelager(){
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json,.csv';
  input.onchange = function(e) {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
      try {
        const fileContent = e.target.result;
        const fileName = file.name.toLowerCase();
        
        let importedData = null;
        
        // Check if CSV file
        if (fileName.endsWith('.csv')) {
          importedData = parseCSVToVarelager(fileContent);
        } else {
          // Try JSON
          importedData = JSON.parse(fileContent);
        }
        
        if (!importedData || !importedData.masterVarelager || !Array.isArray(importedData.masterVarelager)) {
          alert('‚ùå Filen indeholder ikke varelager data i korrekt format.\n\nForventet format:\n‚Ä¢ JSON: {masterVarelager: [...], lagerLokationer: [...]}\n‚Ä¢ CSV: Navn;M√•leenhed;Pris;Placering;Reol;Hylle;R√¶kkef√∏lge');
          return;
        }
        
        // Load existing data or create new
        const storageKey = 'k√∏kkenlager_data';
        let existingData = {};
        const existingStr = localStorage.getItem(storageKey);
        if (existingStr) {
          try {
            existingData = JSON.parse(existingStr);
          } catch(err) {
            console.warn('Could not parse existing data:', err);
          }
        }
        
        // Merge imported varelager with existing data
        existingData.masterVarelager = importedData.masterVarelager;
        if (importedData.lagerLokationer) {
          existingData.lagerLokationer = importedData.lagerLokationer;
        }
        
        // Sync installation ID from main program - ALWAYS update to match
        if (importedData.mainInstallationId) {
          existingData.mainInstallationId = importedData.mainInstallationId;
          // Extract numeric part from main ID (e.g., "INST-123456" -> "123456")
          const mainIdNum = importedData.mainInstallationId.replace(/[^0-9]/g, '');
          // Create matching scanner ID
          const newScannerId = 'SCANNER-' + mainIdNum;
          existingData.scannerInstallationId = newScannerId;
          existingData.installationId = newScannerId;
          console.log('‚úÖ ID synkroniseret fra hovedprogram:', {
            main: importedData.mainInstallationId,
            scanner: newScannerId
          });
        }
        
        // Save merged data
        localStorage.setItem(storageKey, JSON.stringify(existingData));
        
        // Reload items
        allItems = importedData.masterVarelager;
        
        const locationInfo = importedData.lagerLokationer && importedData.lagerLokationer.length > 0 
          ? '\nüìç Placeringer: ' + importedData.lagerLokationer.join(', ')
          : '';
        
        alert('‚úÖ Varelager importeret!\n\n' + allItems.length + ' varer er nu tilg√¶ngelige.' + locationInfo);
        updateStatus('‚úÖ Varelager importeret: ' + allItems.length + ' varer' + locationInfo, 'success');
        
        if (importedData.lagerLokationer && Array.isArray(importedData.lagerLokationer)) {
          console.log('Imported locations:', importedData.lagerLokationer);
        }
        
        console.log('Imported varelager:', allItems.length, 'items');
      } catch(err) {
        alert('‚ùå Fejl ved import: ' + err.message);
        console.error('Import error:', err);
      }
    };
    reader.readAsText(file);
  };
  input.click();
}

async function stopScanner(){
  scannerActive = false;
  const status = document.getElementById('status');
  const video = document.getElementById('scannerVideo');
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  
  if(html5QrCode){
    try {
      if(html5QrCode.isScanning){
        await html5QrCode.stop();
      }
      html5QrCode.clear();
    } catch(err){
      console.warn('Fejl ved stop:', err);
    }
    html5QrCode = null;
  }
  
  video.style.display = 'none';
  startBtn.style.display = 'block';
  stopBtn.style.display = 'none';
  updateStatus('Scanner stoppet', 'waiting');
}

function finishSession(){
  const items = Object.values(scannedItems);
  if(items.length === 0){
    updateStatus('‚ö†Ô∏è Ingen varer scannet. Tilf√∏j varer f√∏r du afslutter.', 'error');
    return;
  }
  
  if(scannerActive){
    stopScanner();
  }
  
  try {
    // Filter items by selected location if a location was selected
    let filteredItems = items;
    if (selectedLocation && selectedLocation !== '') {
      filteredItems = items.filter(item => {
        const itemLocation = item.vare?.placering || '';
        return itemLocation === selectedLocation;
      });
      
      if (filteredItems.length === 0) {
        alert('‚ö†Ô∏è Ingen varer fundet for den valgte lokation.\n\nTjek at du har scannet varer fra den korrekte lokation.');
        return;
      }
    }
    
    // Get session counter from main app
    const storageKey = 'k√∏kkenlager_data';
    let data = {};
    const existingData = localStorage.getItem(storageKey);
    if (existingData) {
      try {
        data = JSON.parse(existingData);
      } catch (e) {
        console.error('Error parsing existing data:', e);
        data = {};
      }
    }
    
    // Get current sessionCounter and increment
    let currentSessionCounter = data.sessionCounter || 0;
    currentSessionCounter++;
    const sessionCounter = currentSessionCounter;
    
    // Create ONE report with all items
    const details = [];
    let grandTotal = 0;
    
    // Process all items and track locations
    const allLocations = new Set();
    
    filteredItems.forEach(item => {
      const v = item.vare;
      const antal = Number(item.count) || 0;
      if (antal <= 0) return; // Skip items with zero count
      
      // Try to get fresh data from allItems if available (in case varelager was updated)
      // Match on both id and stregkode to find the item - use improved matching
      let freshItem = null;
      if (v.id) {
        const vIdStr = String(v.id).trim();
        const vStregkodeStr = String(v.stregkode || '').trim();
        
        freshItem = allItems.find(i => {
          const iIdStr = String(i.id || '').trim();
          const iStregkodeStr = String(i.stregkode || '').trim();
          
          // Exact matches
          if (iIdStr === vIdStr || iStregkodeStr === vIdStr) return true;
          if (iIdStr === vStregkodeStr || iStregkodeStr === vStregkodeStr) return true;
          
          // Case-insensitive matches
          if (iIdStr.toLowerCase() === vIdStr.toLowerCase() || 
              iStregkodeStr.toLowerCase() === vIdStr.toLowerCase()) return true;
          if (iIdStr.toLowerCase() === vStregkodeStr.toLowerCase() || 
              iStregkodeStr.toLowerCase() === vStregkodeStr.toLowerCase()) return true;
          
          return false;
        });
      }
      
      // If still not found, try to find by the scanned barcode (which might be stored in v.id)
      if (!freshItem && v.id) {
        const scannedBarcode = String(v.id).trim();
        freshItem = allItems.find(i => {
          const iIdStr = String(i.id || '').trim();
          const iStregkodeStr = String(i.stregkode || '').trim();
          
          // Try all combinations
          if (iIdStr === scannedBarcode || iStregkodeStr === scannedBarcode) return true;
          if (iIdStr.toLowerCase() === scannedBarcode.toLowerCase() || 
              iStregkodeStr.toLowerCase() === scannedBarcode.toLowerCase()) return true;
          if (iIdStr.includes(scannedBarcode) || iStregkodeStr.includes(scannedBarcode)) return true;
          if (scannedBarcode.includes(iIdStr) || scannedBarcode.includes(iStregkodeStr)) return true;
          
          return false;
        });
      }
      
      // Use fresh data if available, otherwise use stored data
      const itemData = freshItem || v;
      
      // Ensure all required fields are present - ALWAYS get from fresh item if found
      // If fresh item found, use it completely, otherwise use stored data
      const navn = freshItem ? (freshItem.navn || 'Ukendt vare') : (itemData.navn || v.navn || 'Ukendt vare');
      const pris = freshItem ? Number(freshItem.pris || 0) : Number(itemData.pris || v.pris || 0);
      const linjetotal = antal * pris; // Calculate line total: price * quantity
      grandTotal += linjetotal;
      
      const placering = freshItem ? (freshItem.placering || 'Ikke angivet') : (itemData.placering || v.placering || 'Ikke angivet');
      allLocations.add(placering);
      
      // Get reol and hylle - prioritize fresh item data
      const reolNr = freshItem 
        ? (freshItem.reolNr !== undefined && freshItem.reolNr !== null && freshItem.reolNr !== '' ? freshItem.reolNr : null)
        : (itemData.reolNr !== undefined ? itemData.reolNr : (v.reolNr !== undefined ? v.reolNr : null));
      const hylleNr = freshItem 
        ? (freshItem.hylleNr !== undefined && freshItem.hylleNr !== null && freshItem.hylleNr !== '' ? freshItem.hylleNr : null)
        : (itemData.hylleNr !== undefined ? itemData.hylleNr : (v.hylleNr !== undefined ? v.hylleNr : null));
      
      // Create detail item with ALL required fields - ALWAYS include all fields
      const detailItem = {
        vareId: itemData.id || v.id || 'ukendt',
        navn: navn, // Always include name
        maaleenhed: itemData.maaleenhed || v.maaleenhed || 'stk',
        pris: pris, // Price per unit - always include
        antal: antal, // Quantity scanned - always include
        linjetotal: linjetotal, // Calculated: pris * antal - always include
        placering: placering,
        reolNr: reolNr, // Always include, even if null
        hylleNr: hylleNr // Always include, even if null
      };
      
      details.push(detailItem);
      
      // Debug log to verify data
      console.log('Detail item created:', {
        vareId: detailItem.vareId,
        navn: detailItem.navn,
        reolNr: detailItem.reolNr,
        hylleNr: detailItem.hylleNr,
        antal: detailItem.antal,
        pris: detailItem.pris,
        linjetotal: detailItem.linjetotal,
        placering: detailItem.placering,
        freshItemFound: !!freshItem
      });
    });
    
    // Generate unique report name: OPTA-000004 format
    const reportName = `OPTA-${String(sessionCounter).padStart(6, '0')}`;
    
    // Determine scope based on selected location or actual locations found
    let scope = '';
    if (selectedLocation && selectedLocation !== '') {
      scope = selectedLocation; // Use selected location
    } else if (allLocations.size === 1) {
      scope = Array.from(allLocations)[0]; // Single location found
    } else if (allLocations.size > 1) {
      scope = 'Alle lokationer'; // Multiple locations
    } else {
      scope = 'Ikke angivet';
    }
    
    // Create ONE report with all items
    const report = {
      ts: Date.now(),
      handling: reportName,
      type: 'session',
      scope: scope,
      details: details,
      total: grandTotal
    };
    
    const reports = [report]; // Only one report
    
    // Preserve ALL existing data
    if (!data.reports || !Array.isArray(data.reports)) {
      data.reports = [];
    }
    
    // Check if report already exists (by name and timestamp)
    const reportExists = data.reports.some(r => 
      r.handling === report.handling && 
      Math.abs(r.ts - report.ts) < 1000
    );
    
    if (!reportExists) {
      // Add report to beginning of reports array
      data.reports.unshift(report);
      console.log('‚úÖ New report added:', report.handling, 'with', details.length, 'items');
    } else {
      console.log('‚ö†Ô∏è Report already exists:', report.handling);
    }
    
    // Update sessionCounter
    data.sessionCounter = sessionCounter;
    
    // Clear active session
    data.activeSession = null;
    
    // Add/update metadata
    data.version = data.version || '1.0';
    data.savedAt = Date.now();
    
    // Add unique installation ID for tracking
    // ALWAYS try to sync with main program first, otherwise generate new
    const mainInstallationId = data.mainInstallationId || null;
    if (mainInstallationId && mainInstallationId.startsWith('INST-')) {
      // Use main program's ID as base - extract numeric part and create matching scanner ID
      const mainIdNum = mainInstallationId.replace(/[^0-9]/g, '');
      const newScannerId = 'SCANNER-' + mainIdNum;
      // Always update to ensure they match
      data.installationId = newScannerId;
      data.scannerInstallationId = newScannerId;
      console.log('‚úÖ Synced scanner ID with main program:', {
        main: mainInstallationId,
        scanner: newScannerId
      });
    } else if (!data.installationId || !data.installationId.startsWith('SCANNER-')) {
      // Generate unique ID if main program ID not available
      data.installationId = 'SCANNER-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
      data.scannerInstallationId = data.installationId;
      console.log('‚ö†Ô∏è Generated new scanner ID (main program ID not found):', data.installationId);
    }
    
    // Add report metadata
    report.source = 'stregkode-scanner';
    report.installationId = data.installationId;
    
    // Save all data to localStorage
    const savedData = JSON.stringify(data);
    try {
      localStorage.setItem(storageKey, savedData);
      localStorage.removeItem('activeSession');
      
      // Verify save was successful
      const verifyData = localStorage.getItem(storageKey);
      if (!verifyData) {
        throw new Error('Kunne ikke gemme data i localStorage');
      }
      
      console.log('‚úÖ Data saved and verified. Report:', reportName, 'Items:', details.length);
    } catch(saveErr) {
      console.error('Save error:', saveErr);
      alert('‚ö†Ô∏è Fejl ved gemning af rapport!\n\n' + saveErr.message + '\n\nPr√∏v at genindl√¶se siden og pr√∏v igen.');
      throw saveErr;
    }
    
    const totalItems = filteredItems.reduce((sum, item) => sum + item.count, 0);
    const uniqueItems = filteredItems.length;
    const locationsCount = allLocations.size;
    
    const locationInfo = selectedLocation && selectedLocation !== '' 
      ? ` for lokation: ${selectedLocation}` 
      : ` i ${locationsCount} lokation(er)`;
    
    updateStatus(`‚úÖ Rapport oprettet! ${reportName} - ${uniqueItems} unikke varer, ${totalItems} total antal${locationInfo}`, 'success');
    
    console.log('‚úÖ Report saved successfully:', reportName, 'with', details.length, 'items, total:', grandTotal);
    
    // Clear scanned items and reset location
    scannedItems = {};
    selectedLocation = ''; // Reset location for next session
    updateStats();
    renderList();
    
    // Check if running on same domain as main program
    const currentDomain = window.location.hostname;
    const isSameDomain = currentDomain && !currentDomain.includes('github.io') && currentDomain !== '';
    
    let exportInfo = '';
    if (isSameDomain) {
      exportInfo = `\n\n‚úÖ Rapporterne er automatisk synkroniseret med hovedprogrammet!\n\nüí° Tip: G√• til hovedprogrammet og klik "üîÑ Synkroniser Rapporter" for at opdatere listen.`;
    } else {
      exportInfo = `\n\nüí° Tip: For at f√• rapporterne ind i hovedprogrammet:\n\n1. Klik "üì§ Eksport rapporter" knappen nedenfor\n2. I hovedprogrammet: "Ops√¶tning" ‚Üí "Import data" ‚Üí "üì∑ Importer Scanner Data"\n3. V√¶lg den downloadede fil\n\nEller brug "üîÑ Synkroniser Rapporter" i hovedprogrammet hvis begge k√∏rer p√• samme enhed.`;
    }
    
    // Verify report was saved
    const verifyData = localStorage.getItem(storageKey);
    let saveStatus = '';
    if (verifyData) {
      try {
        const verify = JSON.parse(verifyData);
        const found = verify.reports && verify.reports.some(r => r.handling === reportName);
        if (found) {
          saveStatus = '\n\n‚úÖ Rapport gemt og verificeret!';
        } else {
          saveStatus = '\n\n‚ö†Ô∏è Rapport gemt, men verificering fejlede.';
        }
      } catch(e) {
        saveStatus = '\n\n‚ö†Ô∏è Kunne ikke verificere gemning.';
      }
    }
    
    const locationText = selectedLocation && selectedLocation !== '' 
      ? `üìç Lokation: ${selectedLocation}` 
      : `üìç ${locationsCount} lokation(er)`;
    
    alert(`‚úÖ Opt√¶lling afsluttet!\n\nüìã Rapport: ${reportName}\nüìä ${uniqueItems} unikke varer, ${totalItems} total antal\n${locationText}\nüí∞ Total v√¶rdi: ${grandTotal.toFixed(2)} kr.${saveStatus}${exportInfo}`);
    
  } catch(err){
    console.error('Fejl ved oprettelse af rapport:', err);
    updateStatus('Fejl ved oprettelse af rapport: ' + err.message, 'error');
  }
}

// Upload reports to server (GitHub Gist)
async function uploadReportsToServer(){
  try {
    const storageKey = 'k√∏kkenlager_data';
    const dataStr = localStorage.getItem(storageKey);
    
    if (!dataStr) {
      alert('‚ö†Ô∏è Ingen data fundet at uploade.');
      return;
    }
    
    const data = JSON.parse(dataStr);
    
    if (!data.reports || !Array.isArray(data.reports) || data.reports.length === 0) {
      alert('‚ö†Ô∏è Ingen rapporter at uploade.\n\nAfslut en opt√¶lling f√∏rst.');
      return;
    }
    
    // Filter only scanner reports and get the MOST RECENT one only
    const scannerReports = data.reports.filter(r => 
      r.handling && (r.handling.startsWith('OPTA-') || r.handling.startsWith('Stregkode scanner'))
    );
    
    if (scannerReports.length === 0) {
      alert('‚ö†Ô∏è Ingen scanner rapporter at uploade.\n\nAfslut en opt√¶lling f√∏rst.');
      return;
    }
    
    // Sort by timestamp (newest first) and only upload the MOST RECENT report
    scannerReports.sort((a, b) => (b.ts || 0) - (a.ts || 0));
    const mostRecentReport = scannerReports[0];
    
    // Only upload the most recent report (since you can only have one counting session at a time)
    const reportsToUpload = [mostRecentReport];
    
    // Get GitHub token from localStorage or prompt
    let githubToken = localStorage.getItem('github_gist_token');
    
    if (!githubToken) {
      const token = prompt('üîë Indtast GitHub Personal Access Token:\n\n' +
        '1. G√• til: https://github.com/settings/tokens\n' +
        '2. Klik "Generate new token (classic)"\n' +
        '3. V√¶lg "gist" scope\n' +
        '4. Kopi√©r token og indtast her\n\n' +
        'üí° Token gemmes lokalt og bruges til fremtidige uploads.\n' +
        'üí° Du kan slette token i indstillinger hvis n√∏dvendigt.');
      
      if (!token || !token.trim()) {
        alert('‚ùå Ingen token indtastet. Upload annulleret.');
        return;
      }
      
      githubToken = token.trim();
      localStorage.setItem('github_gist_token', githubToken);
    }
    
    // Create export data - only include the most recent report
    const exportData = {
      reports: reportsToUpload,
      sessionCounter: data.sessionCounter || 0,
      exportedAt: Date.now(),
      version: '1.0',
      source: 'stregkode-scanner',
      installationId: data.installationId || 'SCANNER-UNKNOWN'
    };
    
    // Show loading
    updateStatus('Uploader seneste rapport til server...', 'scanning');
    
    // First, try to find existing scanner reports gist to update it
    let existingGistId = null;
    try {
      const gistsResponse = await fetch('https://api.github.com/gists', {
        headers: {
          'Authorization': `Bearer ${githubToken}`,
          'Accept': 'application/vnd.github.v3+json'
        }
      });
      
      if (gistsResponse.ok) {
        const allGists = await gistsResponse.json();
        // Find the most recent scanner reports gist
        const scannerGists = allGists.filter(gist => 
          gist.description && gist.description.includes('Scanner rapporter')
        );
        
        if (scannerGists.length > 0) {
          // Sort by date (newest first) and use the newest one
          scannerGists.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
          existingGistId = scannerGists[0].id;
          console.log('Found existing scanner reports gist to update:', existingGistId);
        }
      }
    } catch (err) {
      console.warn('Could not check for existing gists, will create new one:', err);
    }
    
    // Prepare gist data
    const gistData = {
      description: `Scanner rapporter - ${reportsToUpload.length} rapport - ${new Date().toLocaleString('da-DK')}`,
      public: false, // Private gist
      files: {}
    };
    
    // If updating existing gist, get the filename from the existing gist
    if (existingGistId) {
      try {
        const existingGistResponse = await fetch(`https://api.github.com/gists/${existingGistId}`, {
          headers: {
            'Authorization': `Bearer ${githubToken}`,
            'Accept': 'application/vnd.github.v3+json'
          }
        });
        
        if (existingGistResponse.ok) {
          const existingGist = await existingGistResponse.json();
          const existingFiles = Object.keys(existingGist.files || {});
          if (existingFiles.length > 0) {
            // Use the same filename as the existing gist
            gistData.files[existingFiles[0]] = {
              content: JSON.stringify(exportData, null, 2)
            };
          } else {
            // Fallback to new filename
            gistData.files[`scanner-reports.json`] = {
              content: JSON.stringify(exportData, null, 2)
            };
          }
        }
      } catch (err) {
        console.warn('Could not get existing gist details, using new filename:', err);
        gistData.files[`scanner-reports.json`] = {
          content: JSON.stringify(exportData, null, 2)
        };
      }
    } else {
      // New gist - use timestamp filename
      gistData.files[`scanner-reports-${Date.now()}.json`] = {
        content: JSON.stringify(exportData, null, 2)
      };
    }
    
    // Upload or update GitHub Gist
    const url = existingGistId 
      ? `https://api.github.com/gists/${existingGistId}` 
      : 'https://api.github.com/gists';
    const method = existingGistId ? 'PATCH' : 'POST';
    
    const response = await fetch(url, {
      method: method,
      headers: {
        'Authorization': `Bearer ${githubToken}`,
        'Content-Type': 'application/json',
        'Accept': 'application/vnd.github.v3+json'
      },
      body: JSON.stringify(gistData)
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      let errorData;
      try {
        errorData = JSON.parse(errorText);
      } catch {
        errorData = { message: errorText || `HTTP ${response.status}: ${response.statusText}` };
      }
      
      if (response.status === 401) {
        localStorage.removeItem('github_gist_token');
        throw new Error('Ugyldig GitHub token. Token er blevet slettet. Pr√∏v igen og indtast en ny token.');
      }
      
      throw new Error(errorData.message || errorData.error || `HTTP ${response.status}: ${response.statusText}`);
    }
    
    const gist = await response.json();
    const gistUrl = gist.html_url;
    const gistId = gist.id;
    
    // Store gist ID for later retrieval
    if (!data.uploadedGists) data.uploadedGists = [];
    data.uploadedGists.push({
      id: gistId,
      url: gistUrl,
      uploadedAt: Date.now(),
      reportCount: reportsToUpload.length
    });
    localStorage.setItem(storageKey, JSON.stringify(data));
    
    const reportName = mostRecentReport.handling || 'Ukendt';
    
    updateStatus(`‚úÖ Seneste rapport uploadet til server!`, 'success');
    
    const updateText = existingGistId ? 'opdateret' : 'uploadet';
    alert(`‚úÖ Seneste rapport ${updateText}!\n\nüìã Rapport: ${reportName}\n\n` +
      `üîó Gist URL: ${gistUrl}\n\n` +
      `üí° I hovedprogrammet:\n` +
      `1. G√• til "Rapporter" ‚Üí "‚òÅÔ∏è Hent fra Server"\n` +
      `2. Den seneste rapport hentes automatisk!\n\n` +
      `üîë Gist ID: ${gistId.substring(0, 20)}...`);
    
  } catch(err) {
    console.error('Fejl ved upload:', err);
    updateStatus('‚ùå Fejl ved upload: ' + err.message, 'error');
    
    // Check for network errors
    if (err.name === 'TypeError' && err.message.includes('fetch')) {
      alert('‚ùå Fejl ved upload: Ingen internetforbindelse.\n\nTjek din internetforbindelse og pr√∏v igen.');
      return;
    }
    
    // Check for invalid token
    if (err.message.includes('401') || err.message.includes('Bad credentials') || err.message.includes('Unauthorized')) {
      localStorage.removeItem('github_gist_token');
      alert('‚ùå Ugyldig GitHub token.\n\nToken er blevet slettet. Pr√∏v igen og indtast en ny token.\n\n' +
        'üí° G√• til: https://github.com/settings/tokens\n' +
        'üí° Opret et nyt token med "gist" scope.');
      return;
    }
    
    // Generic error
    alert('‚ùå Fejl ved upload: ' + err.message + '\n\nTjek din internetforbindelse og pr√∏v igen.');
  }
}

// Export reports for transfer to main program
function exportReports(){
  try {
    const storageKey = 'k√∏kkenlager_data';
    const dataStr = localStorage.getItem(storageKey);
    
    if (!dataStr) {
      alert('‚ö†Ô∏è Ingen data fundet at eksportere.');
      return;
    }
    
    const data = JSON.parse(dataStr);
    
    if (!data.reports || !Array.isArray(data.reports) || data.reports.length === 0) {
      alert('‚ö†Ô∏è Ingen rapporter at eksportere.\n\nAfslut en opt√¶lling f√∏rst.');
      return;
    }
    
    // Filter only scanner reports (reports created by this app - OPTA- format)
    const scannerReports = data.reports.filter(r => 
      r.handling && (r.handling.startsWith('OPTA-') || r.handling.startsWith('Stregkode scanner'))
    );
    
    if (scannerReports.length === 0) {
      alert('‚ö†Ô∏è Ingen scanner rapporter at eksportere.\n\nAfslut en opt√¶lling f√∏rst.');
      return;
    }
    
    // Get or create installation ID
    if (!data.installationId) {
      data.installationId = 'SCANNER-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
      // Save installation ID
      localStorage.setItem(storageKey, JSON.stringify(data));
    }
    const installationId = data.installationId;
    
    // Create export data
    const exportData = {
      reports: scannerReports,
      sessionCounter: data.sessionCounter || 0,
      exportedAt: Date.now(),
      version: '1.0',
      source: 'stregkode-scanner',
      installationId: installationId
    };
    
    // Create download
    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `scanner-rapporter-${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    const reportNames = scannerReports.map(r => r.handling || 'Ukendt').join(', ');
    alert(`‚úÖ ${scannerReports.length} rapport(er) eksporteret!\n\nüìã Rapporter: ${reportNames}\nüì• Filen er downloadet.\n\nüí° I hovedprogrammet:\n1. G√• til "Ops√¶tning" ‚Üí "Import data"\n2. Klik "üì∑ Importer Scanner Data"\n3. V√¶lg den downloadede fil\n4. Rapporterne importeres automatisk!\n\nüîó Installation ID: ${installationId.substring(0, 20)}...`);
    
  } catch(err) {
    console.error('Fejl ved eksport:', err);
    alert('‚ùå Fejl ved eksport: ' + err.message);
  }
}

// showInstallationId function removed - not needed

/* Fetch varelager from server (GitHub Gist) */
async function fetchVarelagerFromServer(){
  try {
    // Get GitHub token from localStorage or prompt
    let githubToken = localStorage.getItem('github_gist_token');
    
    if (!githubToken) {
      const token = prompt('üîë Indtast GitHub Personal Access Token:\n\n' +
        '1. G√• til: https://github.com/settings/tokens\n' +
        '2. Klik "Generate new token (classic)"\n' +
        '3. V√¶lg "gist" scope\n' +
        '4. Kopi√©r token og indtast her\n\n' +
        'üí° Token gemmes lokalt og bruges til fremtidige downloads.\n' +
        'üí° Du kan slette token i indstillinger hvis n√∏dvendigt.');
      
      if (!token || !token.trim()) {
        alert('‚ùå Ingen token indtastet. Hentning annulleret.');
        return;
      }
      
      githubToken = token.trim();
      localStorage.setItem('github_gist_token', githubToken);
    }
    
    // Show loading
    updateStatus('Henter varelager fra server...', 'waiting');
    
    // Fetch all user's gists
    const response = await fetch('https://api.github.com/gists', {
      headers: {
        'Authorization': `Bearer ${githubToken}`,
        'Accept': 'application/vnd.github.v3+json'
      }
    });
    
    if (!response.ok) {
      if (response.status === 401) {
        localStorage.removeItem('github_gist_token');
        throw new Error('Ugyldig GitHub token. Token er blevet slettet. Pr√∏v igen og indtast en ny token.');
      }
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const gists = await response.json();
    
    // Filter for varelager gists (description contains "Varelager skabelon")
    const varelagerGists = gists.filter(gist => 
      gist.description && gist.description.includes('Varelager skabelon')
    );
    
    if (varelagerGists.length === 0) {
      updateStatus('‚ö†Ô∏è Ingen varelager skabeloner fundet p√• serveren.', 'error');
      alert('‚ö†Ô∏è Ingen varelager skabeloner fundet i dine gists.\n\nUpload varelager fra hovedprogrammet f√∏rst:\n\n1. G√• til "Varelager administration" ‚Üí "S√∏g & Se hele Varelager"\n2. Klik "‚òÅÔ∏è Upload Varelager til Server"');
      return;
    }
    
    // Sort by date (newest first) and automatically use the newest
    varelagerGists.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
    
    // Check if there's a newer varelager than what we have
    const lastVarelagerTime = localStorage.getItem('scanner_last_varelager_time');
    const newestGistTime = new Date(varelagerGists[0].created_at).getTime();
    
    if(lastVarelagerTime && parseInt(lastVarelagerTime) < newestGistTime) {
      // New varelager available - show notification
      const notificationEl = document.getElementById('varelagerUpdateNotificationScanner');
      if(notificationEl) {
        notificationEl.style.display = 'block';
      }
    }
    
    // Always use the newest varelager - no need to ask user
    let selectedGist = varelagerGists[0];
    
    // If there are multiple old versions, inform user but use newest
    if (varelagerGists.length > 1) {
      console.log(`Found ${varelagerGists.length} varelager versions, using newest from ${new Date(selectedGist.created_at).toLocaleString('da-DK')}`);
    }
    
    // Fetch the selected gist content
    const gistResponse = await fetch(`https://api.github.com/gists/${selectedGist.id}`, {
      headers: {
        'Authorization': `Bearer ${githubToken}`,
        'Accept': 'application/vnd.github.v3+json'
      }
    });
    
    if (!gistResponse.ok) {
      const errorText = await gistResponse.text();
      let errorData;
      try {
        errorData = JSON.parse(errorText);
      } catch {
        errorData = { message: errorText || `HTTP ${gistResponse.status}: ${gistResponse.statusText}` };
      }
      
      if (gistResponse.status === 401) {
        localStorage.removeItem('github_gist_token');
        throw new Error('Ugyldig GitHub token. Token er blevet slettet. Pr√∏v igen og indtast en ny token.');
      }
      
      throw new Error(errorData.message || errorData.error || `HTTP ${gistResponse.status}: ${gistResponse.statusText}`);
    }
    
    const gistDetails = await gistResponse.json();
    
    // Get the first file content
    const files = Object.values(gistDetails.files || {});
    if (files.length === 0) {
      throw new Error('Ingen filer fundet i gist');
    }
    
    const fileContent = files[0].content;
    const importedData = JSON.parse(fileContent);
    
    if (!importedData || !importedData.masterVarelager || !Array.isArray(importedData.masterVarelager)) {
      throw new Error('Filen indeholder ikke varelager data i korrekt format.');
    }
    
    // Load existing data or create new
    const storageKey = 'k√∏kkenlager_data';
    let existingData = {};
    const existingStr = localStorage.getItem(storageKey);
    if (existingStr) {
      try {
        existingData = JSON.parse(existingStr);
      } catch(err) {
        console.warn('Could not parse existing data:', err);
      }
    }
    
    // Merge imported varelager with existing data
    existingData.masterVarelager = importedData.masterVarelager;
    if (importedData.lagerLokationer) {
      existingData.lagerLokationer = importedData.lagerLokationer;
    }
    
    // Sync installation ID from main program - ALWAYS update to match
    if (importedData.mainInstallationId) {
      existingData.mainInstallationId = importedData.mainInstallationId;
      const mainIdNum = importedData.mainInstallationId.replace(/[^0-9]/g, '');
      const newScannerId = 'SCANNER-' + mainIdNum;
      existingData.scannerInstallationId = newScannerId;
      existingData.installationId = newScannerId;
      console.log('‚úÖ ID synkroniseret fra hovedprogram:', {
        main: importedData.mainInstallationId,
        scanner: newScannerId
      });
    }
    
    // Validate that all items have required fields (inkluder billeder og varenummer)
    const validatedItems = importedData.masterVarelager.map(item => {
      // Ensure all required fields are present, including stregkode, billede and varenummer
      return {
        id: item.id || '',
        navn: item.navn || 'Ukendt vare',
        placering: item.placering || 'Ikke angivet',
        maaleenhed: item.maaleenhed || 'stk',
        pris: item.pris !== undefined ? Number(item.pris) : 0,
        reolNr: item.reolNr !== undefined ? item.reolNr : null,
        hylleNr: item.hylleNr !== undefined ? item.hylleNr : null,
        raekkefoelge: item.raekkefoelge !== undefined ? item.raekkefoelge : null,
        stregkode: item.stregkode || item.id || '', // Include stregkode - use id as fallback
        billede: item.billede || null, // Inkluder billede hvis tilg√¶ngelig
        varenummer: item.varenummer || null // Inkluder varenummer hvis tilg√¶ngelig
      };
    });
    
    // Save merged data with validated items
    existingData.masterVarelager = validatedItems;
    localStorage.setItem(storageKey, JSON.stringify(existingData));
    
    // Mark as fetched and clear notification
    const gistTime = new Date(selectedGist.created_at).getTime();
    localStorage.setItem('scanner_last_varelager_time', gistTime.toString());
    const notificationEl = document.getElementById('varelagerUpdateNotificationScanner');
    if(notificationEl) {
      notificationEl.style.display = 'none';
    }
    
    // Reload items
    allItems = validatedItems;
    availableLocations = importedData.lagerLokationer || [];
    if (availableLocations.length === 0 && allItems.length > 0) {
      const uniqueLocs = [...new Set(allItems.map(item => item.placering).filter(p => p))];
      availableLocations = uniqueLocs;
    }
    
    // Debug: Check sample items to verify all fields
    if (allItems.length > 0) {
      const sampleItem = allItems[0];
      console.log('Sample item from server:', {
        id: sampleItem.id,
        navn: sampleItem.navn,
        reolNr: sampleItem.reolNr,
        hylleNr: sampleItem.hylleNr,
        pris: sampleItem.pris,
        placering: sampleItem.placering
      });
    }
    
    const locationInfo = availableLocations.length > 0 
      ? '\nüìç Placeringer: ' + availableLocations.join(', ')
      : '';
    
    const itemsWithReol = allItems.filter(item => item.reolNr !== null && item.reolNr !== undefined).length;
    const itemsWithHylle = allItems.filter(item => item.hylleNr !== null && item.hylleNr !== undefined).length;
    
    updateStatus(`‚úÖ Varelager hentet fra server! ${allItems.length} varer${locationInfo}`, 'success');
    
    alert(`‚úÖ Varelager hentet fra server!\n\n` +
      `üì¶ ${allItems.length} varer er nu tilg√¶ngelige.${locationInfo}\n\n` +
      `üìä Validering:\n` +
      `‚Ä¢ Varer med reol: ${itemsWithReol}\n` +
      `‚Ä¢ Varer med hylle: ${itemsWithHylle}\n\n` +
      `üí° Du kan nu starte opt√¶lling!`);
    
    console.log('Varelager fetched from server:', allItems.length, 'items');
    console.log('Items with reolNr:', itemsWithReol, 'Items with hylleNr:', itemsWithHylle);
    
  } catch(err) {
    console.error('Fejl ved hentning:', err);
    updateStatus('‚ùå Fejl ved hentning: ' + err.message, 'error');
    
    // Check for network errors
    if (err.name === 'TypeError' && err.message.includes('fetch')) {
      alert('‚ùå Fejl ved hentning: Ingen internetforbindelse.\n\nTjek din internetforbindelse og pr√∏v igen.');
      return;
    }
    
    // Check for invalid token
    if (err.message.includes('401') || err.message.includes('Bad credentials') || err.message.includes('Ugyldig') || err.message.includes('Unauthorized')) {
      localStorage.removeItem('github_gist_token');
      alert('‚ùå Ugyldig GitHub token.\n\nToken er blevet slettet. Pr√∏v igen og indtast en ny token.\n\n' +
        'üí° G√• til: https://github.com/settings/tokens\n' +
        'üí° Opret et nyt token med "gist" scope.');
      return;
    }
    
    // Check for not found
    if (err.message.includes('404')) {
      alert('‚ùå Gist ikke fundet.\n\nTjek at Gist ID er korrekt.');
      return;
    }
    
    // Generic error
    alert('‚ùå Fejl ved hentning: ' + err.message + '\n\nTjek din internetforbindelse og pr√∏v igen.');
  }
}

// Opdater versionsnummer i header
function updateVersionDisplayScanner(){
  const versionDisplay = document.getElementById('versionDisplayScanner');
  if(versionDisplay){
    versionDisplay.textContent = APP_VERSION;
  }
  // Opdater ogs√• i title
  const titleEl = document.getElementById('scannerTitle');
  if(titleEl) {
    titleEl.textContent = `Stregkode Scanner - Telefon v${APP_VERSION}`;
  }
  document.title = `Stregkode Scanner - Telefon v${APP_VERSION}`;
}

// Wait for DOM and library to load
document.addEventListener('DOMContentLoaded', function() {
  console.log('DOM loaded, initializing scanner...');
  
  // Opdater versionsnummer ved opstart
  updateVersionDisplayScanner();
  
  // Check if Html5Qrcode library is loaded
  if (typeof Html5Qrcode === 'undefined') {
    console.warn('Html5Qrcode library not loaded yet, waiting...');
    // Wait a bit for library to load
    setTimeout(function() {
      if (typeof Html5Qrcode === 'undefined') {
        updateStatus('‚ö†Ô∏è Scanner bibliotek ikke indl√¶st. Genindl√¶s siden.', 'error');
        console.error('Html5Qrcode library still not loaded after timeout');
      } else {
        console.log('Html5Qrcode library loaded successfully');
        initializeApp();
      }
    }, 1000);
  } else {
    console.log('Html5Qrcode library already loaded');
    initializeApp();
  }
});

// Check for new varelager on server
async function checkForNewVarelager() {
  try {
    const githubToken = localStorage.getItem('github_gist_token');
    if(!githubToken) return; // No token, can't check
    
    const response = await fetch('https://api.github.com/gists', {
      headers: {
        'Authorization': `Bearer ${githubToken}`,
        'Accept': 'application/vnd.github.v3+json'
      }
    });
    
    if(!response.ok) return;
    
    const gists = await response.json();
    const varelagerGists = gists.filter(gist => 
      gist.description && gist.description.includes('Varelager skabelon')
    );
    
    if(varelagerGists.length === 0) return;
    
    varelagerGists.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
    const newestGistTime = new Date(varelagerGists[0].created_at).getTime();
    const lastVarelagerTime = localStorage.getItem('scanner_last_varelager_time');
    
    if(!lastVarelagerTime || parseInt(lastVarelagerTime) < newestGistTime) {
      const notificationEl = document.getElementById('varelagerUpdateNotificationScanner');
      if(notificationEl) {
        notificationEl.style.display = 'block';
      }
    }
  } catch(err) {
    console.warn('Could not check for new varelager:', err);
  }
}

function initializeApp() {
  console.log('Initializing app...');
  
  // Check for new varelager on server
  checkForNewVarelager();
  
  if(loadItemsFromMainApp()){
    updateStatus('Klar til scanning - Klik "Start Scanner"', 'waiting');
    console.log('App initialized successfully');
  } else {
    updateStatus('‚ö†Ô∏è Ingen varelager data fundet. Opret varer i hovedprogrammet f√∏rst.', 'error');
    console.warn('No varelager data found');
  }
}

// Also try to initialize immediately (in case DOM is already loaded)
if (document.readyState === 'loading') {
  // DOM is still loading, wait for DOMContentLoaded
  console.log('DOM still loading, waiting for DOMContentLoaded...');
} else {
  // DOM is already loaded
  console.log('DOM already loaded, initializing immediately...');
  if (typeof Html5Qrcode === 'undefined') {
    setTimeout(function() {
      if (typeof Html5Qrcode !== 'undefined') {
        initializeApp();
      }
    }, 500);
  } else {
    initializeApp();
  }
}
</script>
</body>
</html>